# 堆栈

栈内存 先进后出

原始值 都存 栈内存
```
let a = 1;
let b = a;
```
此时 a,b 在栈内存都有存 1

修改a的值是重新开辟内存空间,并非在原地址修改,不影响b在内存的中的1,所以b的值依然为1

复杂类型 把引用存储在 栈内存 值存储 在 堆内存
```
let arr1 = [1];
let arr2 = arr1;
```
如果 arr1.push(2) // arr2 =[1,2] 直接修改堆内存中的值,所有arr1与arr2的值都发生变化

如果 arr1 = [1,2,3] // arr2 =[1],相当于为arr1重新开辟内存空间, arr2依然保持了原来的引用,值为[1]


js中的数据类型内存为啥要分堆栈在存储


栈储存无论分配新的空间还是释放空间（压栈和退栈）都很简单，访问栈里的变量也快速但其缺点是每次压栈的空间大小是固定的，因此里面的变量的数目及其数据结构大小（类型）也是固定的，不能适应可变大小的、分配时间和数目是动态的 储存。此时需要用堆的内存结构再有，压栈退栈是随着函数调用同步进行的，当函数结束后其栈空间立即被释放，里面的变量的数据无法保留。如果要保留，让函数外面的继续使用（比如闭包），必须将其存入堆。堆储存的特点是不会随函数的结束而自动让数据消失从数据的储存看，栈不能全取代堆，但堆可以取代栈（全部存在堆里）堆在分配和释放空间时要做相当多的工作，比如分配时寻找合适大小的空间，对不用的空间做垃圾扫描和回收（GC），甚至要将碎片化的空闲空间整合在一起。此外访问堆里的数据也要比栈更慢。所有这些都让堆储存的运行代价很高，影响性能所以对于数据结构固定的变量应尽量存放在栈里数据在堆里的地址是不确定的，没有规律的可预先判断的。如何找到堆里分配的数据呢？那要把指向堆里该数据的地址存放在栈里 称为指针的变量里事实上，目前广泛使用的语言 包括js，运行时所有变量都存放在栈里。想要访问堆，只能先找到栈里的指针变量，再取出其中的堆地址所以即使使用了堆储存，也离不开栈